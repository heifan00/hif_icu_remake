<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【ERROR】Lambda表达式无法通过编译</title>
    <link href="/error_lambda_final/"/>
    <url>/error_lambda_final/</url>
    
    <content type="html"><![CDATA[<h2 id="编译器告警内容"><a href="#编译器告警内容" class="headerlink" title="编译器告警内容"></a>编译器告警内容</h2><blockquote><p>Variable used in lambda expression should be final or effectively final</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/heifan00/img_bed@master/Work/hei-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230915170012.webp" alt="image"></p><p>使用IDEA给的解决方案</p><p><img src="https://cdn.jsdelivr.net/gh/heifan00/img_bed@master/Work/hei-error2_20230915170253.webp" alt="image"></p><h2 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h2><blockquote><p><em>lambda表达式中使用的变量应该是final或者有效的final</em>，也就是说，lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p><p>如果一个变量（当前作用域）允许被第二次赋值，则 Lambda 表达式会抛出编译错误。</p></blockquote><p>Java 8 之后，在匿名类或 Lambda 表达式中访问的局部变量，如果不是 final 类型的话，编译器自动加上 final 修饰符，即Java8的特性：effectively final。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>外部的局部变量 final 和匿名内部类里面的 final 是否是同一个变量？</strong></p><p>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接，方法出口等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>在执行方法的时候，<strong>局部变量会保存在栈中，方法结束局部变量也会出栈，随后会被垃圾回收掉</strong>，而此时，内部类对象可能还存在，如果内部类对象这时直接去访问局部变量的话就会出问题，因为外部局部变量已经被回收了，解决办法就是<strong>把匿名内部类要访问的局部变量复制一份作为内部类对象的成员变量</strong>，查阅资料或者通过反编译工具对代码进行反编译会发现，底层确实定义了一个新的变量，通过内部类构造函数将外部变量复制给内部类变量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java lambda 表达式可以随意引用外部变量，但如果外部变量是在当前作用域声明的，则一定不可以进行第二次赋值，哪怕是在 lambda 语句之后。</p><p><img src="https://cdn.jsdelivr.net/gh/heifan00/img_bed@master/Work/hei-error3_20230915171835.webp" alt="image"></p><h2 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> streamMap() &#123;<br>    List&lt;<span class="hljs-type">Integer</span>&gt; streamList = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br><br>    List&lt;<span class="hljs-type">Integer</span>&gt; oneList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>    List&lt;<span class="hljs-type">Integer</span>&gt; twoList = Arrays.asList(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);<br>    // 二次赋值<br>    oneList = Arrays.asList(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    // 编译器给的解决方案<br>    List&lt;<span class="hljs-type">Integer</span>&gt; finalOneList = oneList;<br>    streamList.stream().<span class="hljs-keyword">forEach</span>(item -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (item &gt; finalOneList.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>))&#123;<br>            <span class="hljs-keyword">log</span>.<span class="hljs-keyword">info</span>(&quot;-----------&quot;);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">log</span>.<span class="hljs-keyword">info</span>(&quot;===========&quot;);<br>        &#125;<br>    &#125;);<br>    finalOneList = twoList;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ERROR</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器使用Docker容器安装Redis</title>
    <link href="/linux_docker_redis/"/>
    <url>/linux_docker_redis/</url>
    
    <content type="html"><![CDATA[<h2 id="选择合适的Redis版本"><a href="#选择合适的Redis版本" class="headerlink" title="选择合适的Redis版本"></a>选择合适的Redis版本</h2><p>可以去docker hub中去找一下，<a href="https://hub.docker.com/_/redis?tab=tags">redis - Official Image | Docker Hub</a></p> <span id="more"></span> <p><img src="https://jsd.cdn.zzko.cn/gh/heifan00/img_bed@master/Work/hei-image.jpg"></p><p>这里我选择7.0.11版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker pull redis:7.0.11<br></code></pre></td></tr></table></figure><h2 id="新建配置文件目录及数据持久化目录"><a href="#新建配置文件目录及数据持久化目录" class="headerlink" title="新建配置文件目录及数据持久化目录"></a>新建配置文件目录及数据持久化目录</h2><blockquote><p>我放在&#x2F;docker目录下</p></blockquote><p>redis.conf文件放到配置文件目录下（没这个文件可以去官网下载）</p><p>修改配置文件信息</p><p><code>bind 127.0.0.1</code> #注释掉这部分，使redis可以外部访问&#x20;</p><p><code>daemonize no</code>#用守护线程的方式启动&#x20;</p><p><code>requirepass 你的密码</code>#给redis设置密码</p><p><code>appendonly yes</code>#redis持久化　　默认是no&#x20;</p><p><code>tcp-keepalive 300</code> #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300</p><h2 id="原神启动！"><a href="#原神启动！" class="headerlink" title="原神启动！"></a>原神启动！</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run -p 6379:6379 --name redis -v /docker/redis/conf/redis.conf:/etc/redis/redis.conf  -v /docker/redis/data:/data -d redis:7.0.11 redis-server /etc/redis/redis.conf --appendonly <span class="hljs-built_in">yes</span><br>c8898e38c5fa49703c9d9ac7df91e36add9e112cbf67256c9a2b3e0dd96c3b28<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tutorials</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Docker</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
