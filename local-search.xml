<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git开发流程规范「v1」</title>
    <link href="/git_dev_v1/"/>
    <url>/git_dev_v1/</url>
    
    <content type="html"><![CDATA[<h2 id="分支规范"><a href="#分支规范" class="headerlink" title="分支规范"></a>分支规范</h2><blockquote><p>git 分支分为集成分支、功能分支和修复分支，分别命名为 develop、feature 和 hotfix，均为单数。不可使用 features、future、hotfixes、hotfixs 等错误名称。</p></blockquote><p>1.git主分支(master)。它是自动建立，用于发布重大版本更新（github 现在默认是是main 因种族歧视问题）<br>2.git开发主分支(develop)。日常开发在此分支上进行<br>3.git临时性分支：用于应对一些特定目的的版本开发(验证OK后，应该删除此分支)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>功能（feature）分支：它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。可以采用feature-的形式命名。<br><span class="hljs-bullet">- </span>预发布（release）分支：指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，<br>必须合并进Develop和Master分支。它的命名，可以采用release-的形式。<br><span class="hljs-bullet">- </span>修补bug（hotfix）分支：软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。修补bug分支是从Master或Develop分支上面分出来的。修补结束以后，<br>再合并进Master和Develop分支。它的命名，可以采用hotfix-<span class="hljs-strong">***</span>的形式。<br></code></pre></td></tr></table></figure><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><blockquote><p>暂定临时分支feature、hotfix两种启用。暂不启用RP、code review。</p></blockquote><p>1.基于develop生成新临时开发分支。<br>2.测试、正式环境上线通过。<br>3.合并至develop分支，并生成对应的tag版本。<br>4.完成特定功能开发后(验证OK后，应该删除此分支)。<br>5.README.md文档中记录tag版本生成时间以及具体的功能名称。</p><p>修复bug流程</p><blockquote><p>根据最新已经上线的分支代码创建hotfix分支。</p></blockquote><p>1.基于develop或者上个tag版本(根据实际情况而定)生成新临时开发分支。<br>2.测试、正式环境上线通过。<br>3.合并至develop分支，并生成对应的tag版本。<br>4.<code>若存在临时开发分支</code>-完成特定功能开发后(验证OK后，应该删除此分支)。<br>5.<code>若存在临时开发分支</code>-临时开发分支合并已经修复bug的develop代码。<br>6.<code>若存在临时开发分支</code>-临时开发分支完成特定功能开发后(验证OK后，应该删除此分支)。<br>7.README.md文档中记录tag版本生成时间以及具体的功能名称。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="开发尺码"><a href="#开发尺码" class="headerlink" title="开发尺码"></a>开发尺码</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua">git checkout develop // 切换开发分支，git pull origin develop 并同步最新的develop分支代码。（强制）<br>git checkout -b feature-sizeGroup //基于develop分支创建新的开发分支（强制）<br>git push origin craftsAddUUID:craftsAddUUID //将本地新分支推送到远程（前本地，后远程）<br>git checkout develop // feature-sizeGroup完成上线后develop分支准备合并分支（强制）<br>git merge feature-sizeGroup // 合并开发功能分支（强制）<br>git tag -a v1<span class="hljs-number">.4</span> -m <span class="hljs-string">&quot;my version 1.4&quot;</span> // 合并完成创建标签备注中简单说明开发功能（强制）<br>git push origin v1<span class="hljs-number">.4</span> // 推送tag标签到远程仓库（强制）<br>git branch -d feature-sizeGroup //删除本地的临时开发分支(非强制)<br>git push origin <span class="hljs-comment">--delete feature-sizeGroup // 删除远程的临时开发分支（强制）</span><br>vim README.md // 保存新增tag版本记录（强制）<br>git add README.md // 追踪README.md文件。（强制）<br>git commit -m <span class="hljs-string">&quot;发布新的tag&quot;</span> // 将暂存区里的改动给提交到本地的版本库（强制）<br>git push origin develop // 推送改动后的develop（强制）<br></code></pre></td></tr></table></figure><h3 id="master-合并周期"><a href="#master-合并周期" class="headerlink" title="master 合并周期"></a>master 合并周期</h3><blockquote><p>每月月底最后几个工作日完成对master 对develop分支的合并。</p></blockquote><h3 id="tag-版本命名"><a href="#tag-版本命名" class="headerlink" title="tag 版本命名"></a>tag 版本命名</h3><blockquote><p>版本命名规范</p></blockquote><ul><li>版本: v1.1.1 ( Build 101001 )</li><li>版本格式 bigVersion.middleVersion.smallVersion</li><li>bigVersion 大版本(年度或者重大更新（强制更新，老版本存在不兼容等情况）) 取值范围 1-99</li><li>middleVersion 迭代版本 取值范围 1-99</li><li>smallVersion bug修复增强发布。 取值范围 1-999</li><li>Build为版本纯数字格式化。</li></ul><h3 id="git帮助文档"><a href="#git帮助文档" class="headerlink" title="git帮助文档"></a>git帮助文档</h3><p><a href="https://gitee.com/all-about-git">git 大全</a></p>]]></content>
    
    
    <categories>
      
      <category>Tutorials</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ERROR】Lambda表达式无法通过编译</title>
    <link href="/error_lambda_final/"/>
    <url>/error_lambda_final/</url>
    
    <content type="html"><![CDATA[<h2 id="编译器告警内容"><a href="#编译器告警内容" class="headerlink" title="编译器告警内容"></a>编译器告警内容</h2><blockquote><p>Variable used in lambda expression should be final or effectively final</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/heifan00/img_bed@master/Work/hei-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230915170012.webp" alt="image"></p><p>使用IDEA给的解决方案</p><p><img src="https://cdn.jsdelivr.net/gh/heifan00/img_bed@master/Work/hei-error2_20230915170253.webp" alt="image"></p><h2 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h2><blockquote><p><em>lambda表达式中使用的变量应该是final或者有效的final</em>，也就是说，lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p><p>如果一个变量（当前作用域）允许被第二次赋值，则 Lambda 表达式会抛出编译错误。</p></blockquote><p>Java 8 之后，在匿名类或 Lambda 表达式中访问的局部变量，如果不是 final 类型的话，编译器自动加上 final 修饰符，即Java8的特性：effectively final。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>外部的局部变量 final 和匿名内部类里面的 final 是否是同一个变量？</strong></p><p>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接，方法出口等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>在执行方法的时候，<strong>局部变量会保存在栈中，方法结束局部变量也会出栈，随后会被垃圾回收掉</strong>，而此时，内部类对象可能还存在，如果内部类对象这时直接去访问局部变量的话就会出问题，因为外部局部变量已经被回收了，解决办法就是<strong>把匿名内部类要访问的局部变量复制一份作为内部类对象的成员变量</strong>，查阅资料或者通过反编译工具对代码进行反编译会发现，底层确实定义了一个新的变量，通过内部类构造函数将外部变量复制给内部类变量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java lambda 表达式可以随意引用外部变量，但如果外部变量是在当前作用域声明的，则一定不可以进行第二次赋值，哪怕是在 lambda 语句之后。</p><p><img src="https://cdn.jsdelivr.net/gh/heifan00/img_bed@master/Work/hei-error3_20230915171835.webp" alt="image"></p><h2 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> streamMap() &#123;<br>    List&lt;<span class="hljs-type">Integer</span>&gt; streamList = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br><br>    List&lt;<span class="hljs-type">Integer</span>&gt; oneList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>    List&lt;<span class="hljs-type">Integer</span>&gt; twoList = Arrays.asList(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);<br>    // 二次赋值<br>    oneList = Arrays.asList(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    // 编译器给的解决方案<br>    List&lt;<span class="hljs-type">Integer</span>&gt; finalOneList = oneList;<br>    streamList.stream().<span class="hljs-keyword">forEach</span>(item -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (item &gt; finalOneList.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>))&#123;<br>            <span class="hljs-keyword">log</span>.<span class="hljs-keyword">info</span>(&quot;-----------&quot;);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">log</span>.<span class="hljs-keyword">info</span>(&quot;===========&quot;);<br>        &#125;<br>    &#125;);<br>    finalOneList = twoList;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ERROR</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器使用Docker容器安装Redis</title>
    <link href="/linux_docker_redis/"/>
    <url>/linux_docker_redis/</url>
    
    <content type="html"><![CDATA[<h2 id="选择合适的Redis版本"><a href="#选择合适的Redis版本" class="headerlink" title="选择合适的Redis版本"></a>选择合适的Redis版本</h2><p>可以去docker hub中去找一下，<a href="https://hub.docker.com/_/redis?tab=tags">redis - Official Image | Docker Hub</a></p> <span id="more"></span> <p><img src="https://jsd.cdn.zzko.cn/gh/heifan00/img_bed@master/Work/hei-image.jpg"></p><p>这里我选择7.0.11版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker pull redis:7.0.11<br></code></pre></td></tr></table></figure><h2 id="新建配置文件目录及数据持久化目录"><a href="#新建配置文件目录及数据持久化目录" class="headerlink" title="新建配置文件目录及数据持久化目录"></a>新建配置文件目录及数据持久化目录</h2><blockquote><p>我放在&#x2F;docker目录下</p></blockquote><p>redis.conf文件放到配置文件目录下（没这个文件可以去官网下载）</p><p>修改配置文件信息</p><p><code>bind 127.0.0.1</code> #注释掉这部分，使redis可以外部访问&#x20;</p><p><code>daemonize no</code>#用守护线程的方式启动&#x20;</p><p><code>requirepass 你的密码</code>#给redis设置密码</p><p><code>appendonly yes</code>#redis持久化　　默认是no&#x20;</p><p><code>tcp-keepalive 300</code> #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300</p><h2 id="原神启动！"><a href="#原神启动！" class="headerlink" title="原神启动！"></a>原神启动！</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run -p 6379:6379 --name redis -v /docker/redis/conf/redis.conf:/etc/redis/redis.conf  -v /docker/redis/data:/data -d redis:7.0.11 redis-server /etc/redis/redis.conf --appendonly <span class="hljs-built_in">yes</span><br>c8898e38c5fa49703c9d9ac7df91e36add9e112cbf67256c9a2b3e0dd96c3b28<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tutorials</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Docker</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
